\documentclass[hidelinks,11pt]{article}

\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{caption}
\usepackage{siunitx}
\usepackage{comment}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{dsfont}
\usepackage{minted}

% separate main text and appendix
\usepackage{selectp}
%\outputonly{1-13}
%\outputonly{14-22}

% preprint
%\usepackage{lineno}
%\usepackage{geometry}
%\geometry{margin=25mm}

%\usepackage{setspace}
%\doublespacing

\usepackage[round]{natbib}
\usepackage{mathtools}
\bibliographystyle{plainnat}

%\captionsetup{
%    font={stretch=2}
%}
% end preprint

\captionsetup{width=0.95\textwidth}

% tolerance for line breaks
\tolerance=400
%\emergencystretch=3em

\title{Simulation and inference on exact solutions of coalescent distributions under diverse demographies.}
\author{Janek Sendrowski\thanks{Bioinformatics Research Center, Aarhus University, Denmark.}, Asger Hobolth\thanks{Department of Mathematics, Aarhus University, Denmark.}\\
Contact:
\href{mailto:sendrowski.janek@birc.au.dk}{\texttt{sendrowski.janek@birc.au.dk}},
    \href{mailto:asger@math.au.dk}{\texttt{asger@math.au.dk}}}

\date{\today}

\begin{document}

    \maketitle

% preprint
%\linenumbers

    \begin{abstract}
        Coalescent theory has proven to be a powerful framework, but exact solutions have so far only been obtainable under relatively simple scenarios, and current simulators such as msprime only provide stochastic solutions, necessitating the use of approximate Bayesian computation (ABC) for parameter inference.
        Recent advancements in phase-type theory now permit exact solutions for all (joint-)moments of coalescent distributions under complex demographic scenarios.
        These include moments of tree height, total branch length and the site-frequency spectrum (SFS) under demographies with multiple demes, varying population sizes and migration rates, multiple merger coalescents, and, to some extent, multiple loci.
        Here we present the theory underlying these developments and propose PhaseGen -- a Python-based software package simulating these moments, and incorporating a maximum likelihood estimation (MLE) framework for parameter inference.
        The package is comprehensively tested, and documented at \href{https://phasegen.readthedocs.io}{\url{phasegen.readthedocs.io}}.
    \end{abstract}


    \section{Introduction}\label{sec:introduction}
    Population genetic simulators are essential tools in evolutionary biology, allowing researchers to explore complex demographic scenarios, develop hypotheses regarding evolutionary processes, and infer parameters under a given demographic model.
    There exists a variety of tools either employing backward or forward simulations, and designed with or without direct parameter inference capabilities.
    Current coalescent-based simulators such as msprime provide stochastic solutions, which gives them great flexibility while mirroring the data generation process~\citep{msprime}. % mention fastsimcoal?
    However, the stochasticity of the results, necessitates the simulation of many replicates for obtaining good estimates of summary statistics, especially when the underlying demographic model is complex and the statistic is based on higher moments.
    Furthermore, parameter inference necessitates the use of approximate Bayesian computation (ABC).

    Another set of tools are forward simulators where the allele frequency trajectories forward in time are described by (often diffusion-based) differential equations~\citep{dadi,moments}.
    The great advantage of forward simulations is that they readily allow for the integration of selection.
    They have, however, different caveats such as model initialization, choice of run times, and they tend to be overall much less efficient that backward simulations. % Too vague? Citation needed
    Furthermore, analytical solutions to the underlying differential equations are rarely available necessitating the use numerical approximations which are not always numerically stable, and higher-order moments are not readily obtainable~\citep{moments}. % more citations, is true?

    Phase-type theory constitutes a unified mathematical framework that offers solutions for mixtures and convolutions of exponential distributions~\citep{phasetype}.
    It is applicable to coalescent theory as the coalescent is phase-type distributed~\citep{phasetype_popgen}.
    One previous limitation of the application of phase-type theory was the restriction to time-homogeneous coalescent processes. % cite Mogens somehow
    However, time-inhomogeneous coalescent processes such as those with changing population sizes or migration rates are common-place in population genetics and necessary to describe realistic demographic scenarios such as population expansion, contraction, splits, mergers, and bottlenecks.
    We describe here how time-inhomogeneous coalescent processes can be described by phase-type distributions, and introduce an implementation of the theory in the software package PhaseGen.


    \section{Phase-type distribution}\label{sec:phase-type-distribution}

% Matrices are written in bold majuscules, column vectors in bold, Roman minuscules while row vectors are bold, Greek minuscules

    \subsection{Introduction}\label{subsec:introduction}

    Consider a Markov jump process $\{X_t\}_{t\geq0}$ with finite state-space $E=\{1, 2, \dots,p\}$ and let $\mathbf{S}(t)=\{s(t)_{ij} \}_{i,j=1,\dots,k}$ be the intensity matrix holding the exponential rates of jumping from state $i$ to $j$ at time $t$.
    Define the time until absorption as % mention that rows sum to zero
    \begin{equation*}
        \tau = \inf\{t>0:X_t \in B\},
    \end{equation*}
    where $B$ is the set of absorbing states. $\tau$ is said to be (time-inhomogeneous) phase-type distributed with state space $E$, initial state vector $\bm{\alpha}=(\alpha_i)_i$ and intensity matrix $\mathbf{S}(t)$, and we write
    \begin{equation*}
        \tau \sim IPH(\bm{\alpha},\mathbf{S}).
    \end{equation*}

    \subsection{The coalescent}\label{subsec:the-coalescent}
    In the following, we construct a state space for describing the tree height for the standard coalescent.
    For this we require a state space $E=\{e_j\}=\{1, \dots, n\}$ with $n$ states, where $n$ denotes the number of initial lineages, and $e_j$ the number of lineages in state $j$.
    The only absorbing state is $B=\{1\}$ and our transition rates are given by
    \begin{equation*}
        s^d_{ij} = \begin{cases}
                       \binom{i}{2} / N_e & \text{if } i = j - 1, \\ 0 & \text{otherwise,}
        \end{cases}
    \end{equation*}
    where states are indexed with respect to the ordering $\phi(i) = i, i \in E$, and $N_e$ is the effective population size.
    Henceforth, we refer to the state space keeping track of the number of lineages at a time as the \textit{default state space}.

    In order to obtain more complex summary statistics such as the site-frequency spectrum (SFS), we need to augment the state space to keep track of the number of lineages that subtend $i$ lineages at a time.
    Let each state be an $n$-tuple $\mathbf{e}=(a_1, a_2, \dots, a_n)$ where $a_i$ denotes the number of lineages that subtend $i$ lineages.
    Our state space is given by $E=\{\mathbf{e}: \sum_i ia_i = n\}$, and the only absorbing state is $B=\{(0, 0, ..., 1)\}$.
    The transition rates are given by
    \begin{align*}
        s^b_{\phi(\mathbf{e}_1),\phi(\mathbf{e}_2)} =
        \begin{cases}
            \binom{a_i}{2} / N_e & \text{if }
            \begin{aligned}[t]
                & \mathbf{e}_1=(a_1,\dots,a_n), \\
                & \mathbf{e}_2=(a_1,\dots,a_i-2,\dots,a_{2i}+1,\dots,a_{n}), \\
                & a_i \geq 2,
            \end{aligned} \\
            a_i a_j / N_e & \text{if }
            \begin{aligned}[t]
                & \mathbf{e}_1=2(a_1,\dots,a_n), \\
                & \mathbf{e}_2=(a_1,\dots,a_i-1,\dots,a_j-1,\dots,a_{i+j}+1,\dots,a_{n}), \\
                & a_i a_j \geq 1,
            \end{aligned} \\
            0 & \text{otherwise,}
        \end{cases}
    \end{align*}
    where $\phi$ is an arbitrary ordering~\citep{phasetype_sfs}.
    We refer to this state space as the \textit{block-counting state space}, and to $a_i$ as \textit{lineage block}.
    Details on how to support multiple demes and two loci are shown in the Appendix (\ref{sec:transition_rates}).

    \subsection{Moments}\label{subsec:moments}

    The first moment of $\tau$ can be written as
    \begin{equation*}
        \mathds{E}(\tau) = \int_0^{\infty} \mathds{1}_{E \backslash B}(X_t) dt,
    \end{equation*}
    where $\mathds{1}_{E \backslash B}$ is the indicator function outputting 1 as long as $X_t$ is in a non-absorbing state and 0 otherwise.

    In order to compute more complex summary statistics such as the total branch length and SFS, we want to assign different weights to each state.
    We do this by defining rewards.
    Let $r: E \rightarrow \mathbb{R}_{\geq 0}$ map each state to its chosen reward.

    Then
    \begin{equation*}
        \int_s^{t} r(X_t) dt,
    \end{equation*}
    is the reward accumulated over time $[s, t]$ with respect to $r$.

    In order to compute this quantity, we need to evaluate
    \begin{equation}
        \label{eq:reward_integral}
        \mathbf{M}(s,t)=\int_s^t \mathbf{P}(s,u)\mathbf{R}(u)\mathbf{P}(u,t) du,
    \end{equation}
    where $\mathbf{P}(s,t)$ is a transition matrix describing the probabilities of transitioning from state $i$ at time $s$ to state $j$ at time $t$, and $\mathbf{R}=\{r_{ii}=r(i)\}$ is the (diagonal) reward matrix.
    $\mathbf{M}(s,t)=\{m_{ij}(s,t)\}$ then holds the accumulated reward over time $[s, t]$.
    Computing $\mathbf{P}(s,t)$ for time-homogeneous processes, i.e.\ were $\mathbf{P}$ is constant over time is straightforward.
    We have
    \begin{equation*}
        \mathbf{P}(s,t) = \exp(\mathbf{S}(t-s)),
    \end{equation*}
    However, determining $\mathbf{P}(s,t)$ for time-inhomogeneous processes requires evaluating a product integral, i.e.,
    \begin{equation} % TODO make descritization step of product integral more explicit. Also make Van Loan's method more explicit by first introducting it for first moments, and invoke the product integral right away, showing the result of Van Loan's method as a matrix with product integrals, and then discretize it
        \label{eq:product_integral}
        \mathbf{P}(s,t) = \prod_s^t (\mathbf{I} + \mathbf{S}(u) du),
    \end{equation}
    which is analytically intractable ($\mathbf{I}$ is the identity matrix).
    However, rather than evaluating~\eqref{eq:product_integral} numerically and accept numerically errors, we propose a scheme in which the demography is discretized into $n$ epochs during which $\mathbf{S}$ is constant.
    We can then obtain exact solutions under this discretized demography.

    We can use Van Loan's method to evaluate~\eqref{eq:reward_integral} and higher-order moments, including cross moments~\citep{van_loan_popgen,van_loan}.

    Assume for now that $\mathbf{S}$ is constant over time.
    Let the Van Loan matrix of order $k$ be the $(k+1) \times (k+1)$ block matrix
    \begin{equation*}
        \mathbf{V}_{k}(\mathbf{S}, \mathbf{R}_1, \dots, \mathbf{R}_k) =
        \begin{bmatrix}
            \mathbf{S} & \mathbf{R}_1 & \mathbf{0}            & \cdots & \mathbf{0}          & \mathbf{0}            \\
            \mathbf{0}          & \mathbf{S}   & \mathbf{R}_2 & \cdots & \mathbf{0}          & \mathbf{0}            \\
            \mathbf{0}          & \mathbf{0}            & \mathbf{S}   & \cdots & \mathbf{0}          & \mathbf{0}            \\
            \vdots     & \vdots       & \vdots       & \ddots & \vdots     & \vdots       \\
            \mathbf{0}          & \mathbf{0}            & \mathbf{0}            & \cdots & \mathbf{S} & \mathbf{R}_k \\
            \mathbf{0}          & \mathbf{0}            & \mathbf{0}            & \cdots & \mathbf{0}          & \mathbf{S}
        \end{bmatrix},
    \end{equation*} % TODO define 0, different notation where V is the Van Loan matrix, and Q the result when exponentiating V?
    where $\mathbf{R}_i$ are reward matrices.
    Note that we can choose the $\mathbf{R}_i$ to be different if we are interested in cross moments.
    Also note that, in practice, we always apply zero rewards to absorbing states.

    Exponentiating $\mathbf{V}_k$, we obtain the accumulated reward per state over time $\delta = t - s$:
    \begin{equation*}
        \mathbf{M}_k(\mathbf{S}, \mathbf{R}_1, \dots, \mathbf{R}_k,\delta) = \exp(\delta\mathbf{V}_k).
    \end{equation*}
    The reward can be obtained by extracting the upper right block of $\mathbf{M}_k$, which we denote $\mathbf{M}_k^{sub}$, whence the final moment can be computed as
    \begin{equation*}
        m_k = k! \cdot \bm{\alpha} \cdot \mathbf{M}_k^{sub} \cdot \mathbf{e},
    \end{equation*}
    where $\bm{\alpha}$ is the initial state vector and $\mathbf{e}$ a vector of ones.

    Now, to obtain the moments for our discretized demography, let $\delta_i$ be the time spent and $\mathbf{S}_i$ the intensity matrix in epoch $i$, respectively.
    We can calculate $\mathbf{M}_k^i = \mathbf{M}_k(\mathbf{S}_i, \mathbf{R}_1, \dots, \mathbf{R}_k,\delta_i)$ for all $i$.
    The matrix containing the total accumulated reward over all epochs is then obtained by
    \begin{equation}
        \label{eq:prod_moments}
        \hat{\mathbf{M}}_k = \prod_i{\mathbf{M}_k^i}.
    \end{equation}

    In practice, sufficiently many epochs are generated so as to ensure we have reached almost sure absorption.
    Note that~\eqref{eq:prod_moments} constitutes a discretization of the product integral~\eqref{eq:product_integral}.

    The accumulated reward in each state can then be obtained by extracting the upper right block of $\hat{\mathbf{M}}_k$, which we denote by $\hat{\mathbf{M}}_k^{sub}$.
    The final moment can then be computed as
    \begin{equation*}
        m_k = k! \cdot \bm{\alpha} \cdot \hat{\mathbf{M}}_k^{sub} \cdot \mathbf{e},
    \end{equation*}
    where $\bm{\alpha}$ is the initial state vector and $\mathbf{e}$ a vector of ones.

    To determine the probability of almost sure absorption, we discretize the transition matrix $\mathbf{P}_i = \exp(\mathbf{S}_i)$, using the same discretization scheme, i.e.,
    \begin{equation*}
        t_{abs} = \min_i\{t: \bm{\alpha} (\prod_i \mathbf{P}_i) \mathbf{e} \approx 0 \},
    \end{equation*}
    where $\bm{\alpha}$ and $\mathbf{e}$ are the same as above.

    \subsection{2-epoch example}\label{subsec:2-epoch-example}
    To illustrate the method, assume we have $n=3$ lineages, a single deme, and a 2-epoch demography with $N_e = 1, t \in [0, 2)$ and $N_e = 0.5, t \in [2, \infty)$.
    Assume furthermore we are interested in the variance of the total branch length so that it will suffice to work with the default state space.
    let $(N_1, N_2) = (1, 0.5)$ be the effective population sizes in epochs 1 and 2.
    Also assume we start with 3 lineages in epoch 1 with a probability of 1, so that $\bm{\alpha} = (1, 0, 0)$.

    We have
    \begin{equation*}
        \mathbf{S}_1 = \{s_{ij}\} =
        \begin{bmatrix}
            -3 & 3 & 0 \\ 0 & -1 & 1 \\ 0 & 0 & 0
        \end{bmatrix}, \quad
        \mathbf{S}_2 = \{s_{ij}\} =
        \begin{bmatrix}
            -6 & 6 & 0 \\ 0 & -2 & 2 \\ 0 & 0 & 0
        \end{bmatrix},
    \end{equation*}
    using an ordering of $\phi(i) = 4-i$ where $i$ is the number of lineages, i.e., state 1 is the state with 3 lineages, etc.
    The reward matrix for the total branch length is given by
    \begin{equation*}
        \mathbf{R} = \begin{bmatrix}
                         3 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & 0
        \end{bmatrix},
    \end{equation*}
    i.e., we reward each non-absorbing state with its number of lineages.
    The resulting Van Loan matrices are
    \begin{equation*}
        \mathbf{V}_1 = \begin{bmatrix}
                           \mathbf{S}_1 & \mathbf{R} & 0 \\ 0 & \mathbf{S}_1 & \mathbf{R} \\ 0 & 0 & \mathbf{S}_1
        \end{bmatrix} = \left [
            \begin{array}{ccc|ccc|ccc}
                -3 & 3  & 0 & 3  & 0  & 0 & 0  & 0  & 0 \\
                0  & -1 & 1 & 0  & 2  & 0 & 0  & 0  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
                \hline
                0  & 0  & 0 & -3 & 3  & 0 & 3  & 0  & 0 \\
                0  & 0  & 0 & 0  & -1 & 1 & 0  & 2  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
                \hline
                0  & 0  & 0 & 0  & 0  & 0 & -3 & 3  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & -1 & 1 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
            \end{array}
            \right ],
    \end{equation*}
    \begin{equation*}
        \mathbf{V}_2 = \begin{bmatrix}
                           \mathbf{S}_2 & \mathbf{R} & 0 \\ 0 & \mathbf{S}_2 & \mathbf{R} \\ 0 & 0 & \mathbf{S}_2
        \end{bmatrix} = \left [
            \begin{array}{ccc|ccc|ccc}
                -6 & 6  & 0 & 3  & 0  & 0 & 0  & 0  & 0 \\
                0  & -2 & 2 & 0  & 2  & 0 & 0  & 0  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
                \hline
                0  & 0  & 0 & -6 & 6  & 0 & 3  & 0  & 0 \\
                0  & 0  & 0 & 0  & -2 & 2 & 0  & 2  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
                \hline
                0  & 0  & 0 & 0  & 0  & 0 & -6 & 6  & 0 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & -2 & 2 \\
                0  & 0  & 0 & 0  & 0  & 0 & 0  & 0  & 0 \\
            \end{array}
            \right ].
    \end{equation*}

    We then compute the accumulated reward per epoch as
    \begin{equation*}
        % result: [[0.002 0.199 0.798 0.015 0.889 1.69  0.045 2.002 2.316]\n [0.    0.135 0.865 0.    0.541 1.188 0.    1.083 1.293]\n [0.    0.    1.    0.    0.    0.    0.    0.    0.   ]\n [0.    0.    0.    0.002 0.199 0.798 0.015 0.889 1.69 ]\n [0.    0.    0.    0.    0.135 0.865 0.    0.541 1.188]\n [0.    0.    0.    0.    0.    1.    0.    0.    0.   ]\n [0.    0.    0.    0.    0.    0.    0.002 0.199 0.798]\n [0.    0.    0.    0.    0.    0.    0.    0.135 0.865]\n [0.    0.    0.    0.    0.    0.    0.    0.    1.   ]]
        \mathbf{M}_1 = \exp(\delta_1\mathbf{V}_1) \approx
        \left [
            \begin{array}{ccc|ccc|ccc}
                0.002 & 0.199 & 0.798 & 0.015 & 0.889 & 1.69  & 0.045 & 2.002 & 2.316 \\
                0     & 0.135 & 0.865 & 0     & 0.541 & 1.188 & 0     & 1.083 & 1.293 \\
                0     & 0     & 1     & 0     & 0     & 0     & 0     & 0     & 0     \\
                \hline
                0     & 0     & 0     & 0.002 & 0.199 & 0.798 & 0.015 & 0.889 & 1.69  \\
                0     & 0     & 0     & 0     & 0.135 & 0.865 & 0     & 0.541 & 1.188 \\
                0     & 0     & 0     & 0     & 0     & 1     & 0     & 0     & 0     \\
                \hline
                0     & 0     & 0     & 0     & 0     & 0     & 0.002 & 0.199 & 0.798 \\
                0     & 0     & 0     & 0     & 0     & 0     & 0     & 0.135 & 0.865 \\
                0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 1
            \end{array}
            \right ],
    \end{equation*}
    \begin{equation*}
        % result [[0.   0.   1.   0.   0.   1.5  0.   0.   1.75]\n [0.   0.   1.   0.   0.   1.   0.   0.   1.  ]\n [0.   0.   1.   0.   0.   0.   0.   0.   0.  ]\n [0.   0.   0.   0.   0.   1.   0.   0.   1.5 ]\n [0.   0.   0.   0.   0.   1.   0.   0.   1.  ]\n [0.   0.   0.   0.   0.   1.   0.   0.   0.  ]\n [0.   0.   0.   0.   0.   0.   0.   0.   1.  ]\n [0.   0.   0.   0.   0.   0.   0.   0.   1.  ]\n [0.   0.   0.   0.   0.   0.   0.   0.   1.  ]]
        \mathbf{M}_2 = \exp(\delta_2\mathbf{V}_2) \approx
        \left [
            \begin{array}{ccc|ccc|ccc}
                0 & 0 & 1 & 0 & 0 & 1.5 & 0 & 0 & 1.75 \\
                0 & 0 & 1 & 0 & 0 & 1   & 0 & 0 & 1    \\
                0 & 0 & 1 & 0 & 0 & 0   & 0 & 0 & 0    \\
                \hline
                0 & 0 & 0 & 0 & 0 & 1   & 0 & 0 & 1.5  \\
                0 & 0 & 0 & 0 & 0 & 1   & 0 & 0 & 1    \\
                0 & 0 & 0 & 0 & 0 & 1   & 0 & 0 & 0    \\
                \hline
                0 & 0 & 0 & 0 & 0 & 0   & 0 & 0 & 1    \\
                0 & 0 & 0 & 0 & 0 & 0   & 0 & 0 & 1    \\
                0 & 0 & 0 & 0 & 0 & 0   & 0 & 0 & 1
            \end{array}
            \right ].
    \end{equation*}
    where $\delta_1 = 2$ and $\delta_2 = t_{abs} \coloneqq 31$, the time until almost sure absorption.

    To obtain the total accumulated reward over all epochs, we compute
    \begin{equation}
        \label{eq:prod_moments_example}
        % result: [[0.    0.    1.    0.    0.    2.797 0.    0.    5.477]\n [0.    0.    1.    0.    0.    1.865 0.    0.    3.053]\n [0.    0.    1.    0.    0.    0.    0.    0.    0.   ]\n [0.    0.    0.    0.    0.    1.    0.    0.    2.797]\n [0.    0.    0.    0.    0.    1.    0.    0.    1.865]\n [0.    0.    0.    0.    0.    1.    0.    0.    0.   ]\n [0.    0.    0.    0.    0.    0.    0.    0.    1.   ]\n [0.    0.    0.    0.    0.    0.    0.    0.    1.   ]\n [0.    0.    0.    0.    0.    0.    0.    0.    1.   ]]
        \hat{\mathbf{M}} = \mathbf{M}_2 \cdot \mathbf{M}_1 \approx
        \left [
            \begin{array}{ccc|ccc|ccc}
                0 & 0 & 1 & 0 & 0 & 2.797 & 0 & 0 & 5.477 \\
                0 & 0 & 1 & 0 & 0 & 1.865 & 0 & 0 & 3.053 \\
                0 & 0 & 1 & 0 & 0 & 0     & 0 & 0 & 0     \\
                \hline
                0 & 0 & 0 & 0 & 0 & 1     & 0 & 0 & 2.797 \\
                0 & 0 & 0 & 0 & 0 & 1     & 0 & 0 & 1.865 \\
                0 & 0 & 0 & 0 & 0 & 1     & 0 & 0 & 0     \\
                \hline
                0 & 0 & 0 & 0 & 0 & 0     & 0 & 0 & 1     \\
                0 & 0 & 0 & 0 & 0 & 0     & 0 & 0 & 1     \\
                0 & 0 & 0 & 0 & 0 & 0     & 0 & 0 & 1
            \end{array}
            \right ],
    \end{equation}
    from which we can extract the total accumulated reward in the upper right block.
    We have
    \begin{equation*}
        % result: [[0.    0.    5.477]\n [0.    0.    3.053]\n [0.    0.    0.   ]]
        \hat{\mathbf{M}}^{sub} \approx \left [
            \begin{array}{ccc}
                0 & 0 & 5.477 \\
                0 & 0 & 3.053 \\
                0 & 0 & 0
            \end{array}
            \right ].
    \end{equation*}

    We can then compute the (uncentered) second moment by
    \begin{equation*}
        m_2 \approx 2! \cdot \bm{\alpha} \cdot \hat{\mathbf{M}}^{sub}\cdot \mathbf{e} = 2 \left [
            \begin{array}{ccc}
                1 & 0 & 0
            \end{array}
            \right ] \left [
            \begin{array}{ccc}
                0 & 0 & 5.477 \\
                0 & 0 & 3.053 \\
                0 & 0 & 0
            \end{array}
            \right ] \left [
            \begin{array}{c}
                1 \\ 1 \\ 1
            \end{array}
            \right ] \approx 10.955.
    \end{equation*}

    After obtaining the mean total branch length $m_1$, using the similar procedure, we can obtain the variance by
    \begin{equation*}
        \sigma^2 = m_2 - m_1^2 \approx 10.955 - 2.797^2 \approx 3.132.
    \end{equation*}


    \section{Runtime}\label{sec:runtime}

    Let $n$ be the number of lineages, $k$ the moment's order, and $d$ the number of demes.
    Furthermore, let $P_0(n, k)$ be the number of partitions of $n$ into $k$ non-negative integer parts. % let $P(n)$ be the number of integer partitions of $n$ and

    % TODO add number of loci here
    The Van Loan matrix for the default state space has size
    \begin{equation*}
        \text{order}(\mathbf{V}^k(\mathbf{S}^d)) = (k + 1) \cdot \sum_{i=1}^{n} P_0(i, d),
    \end{equation*}
    and for the block-counting state space, we have
    \begin{equation*}
        \text{order}(\mathbf{V}^k(\mathbf{S}^d)) = (k + 1) \cdot \sum_{i=1}^{n} \prod_{j \in P_n} P_0(j, d),
    \end{equation*}
    where $P_n$ is the set of partitions of $n$ (cf.\ Figure~\ref{fig:state_space_sizes} for examples).

    % mention time complexity of matrix exponentiation, state space construction, and demography discretization
    % also mention growth rate of state space size with respect to n, k, d
    % Talk about precision of Pad√© approximation


    \section{Implementation}\label{sec:implementation}
    PhaseGen is implemented in Python and offers a high-level interface for simulating time-inhomogeneous coalescent processes.
    It has support for multiple demes, varying population sizes and migration rates, multiple-merger coalescents such as the beta and Dirac coalescents (cf.\ Section~\ref{subsec:beta-coalescent} \& \ref{subsec:dirac-coalescent}).
    Recombination is currently only supported for the default state space.
    Computable summary statistics include moments and cross-moments of essentially any order of the default and block-counting state spaces using an arbitrary reward structure.
    This includes moments of the tree height, total branch length, site-frequency spectrum (SFS).
    The user can also readily marginalize over different demes and loci.
    PhaseGen also provides a light interface for maximum likelihood estimation (MLE) of a parametrized coalescent process (cf.\ Section~\ref{subsec:mle-inference}).

    % mention support for Demes, Msprime
    PhaseGen is equipped with a demography interface akin to Msprime, designed to handle temporal changes.
    This is achieved by discretizing the demography into piece-wise constant epochs, enabling the simulation of more intricate demographic scenarios, such as population expansions and bottlenecks.
    PhaseGen was extensively tested against Msprime, comparing many different statistics across a wide range of different demographic scenarios~\citep{msprime}.


    \section{Code examples}\label{sec:code-examples}

    In the code snippet below, we define a coalescent distribution with a 2-deme, 4-epoch demography and a total number of lineages of \texttt{n=8}.
    As our ancestry model we choose the beta coalescent with \texttt{alpha=1.7}.
    Upon construction the different distributions are available.

    \begin{minted}{python}
import phasegen as pg

coal = pg.Coalescent(
    n=pg.LineageConfig({'pop_0': 3, 'pop_1': 5}),
    model=pg.BetaCoalescent(alpha=1.7),
    demography=pg.Demography(
        pop_sizes={
            'pop_1': {0: 1.2, 5: 0.1, 5.5: 0.8},
            'pop_0': {0: 1.0}
        },
        migration_rates={
            ('pop_0', 'pop_1'): {0: 0.2, 3: 0.3},
            ('pop_1', 'pop_0'): {0: 0.5}
        }
    )
)

    \end{minted}

    We now proceed to plotting some quantities, namely the demography, tree height distribution, expected SFS and correlation matrix of different SFS bins.
    Note that we adjust the maximum time shown to be the 99th percentile of the tree height distribution.
    The output of the snippet below is shown in Figure~\ref{fig:simple-example}

    \begin{minted}{python}
import numpy as np
import matplotlib.pyplot as plt

_, axs = plt.subplots(2, 2, figsize=(9, 7))
t = np.linspace(0, coal.tree_height.quantile(0.99), 100)

coal.demography.plot(ax=axs[0, 0], show=False, t=t)
coal.tree_height.plot_pdf(ax=axs[0, 1], show=False)
coal.sfs.mean.plot(ax=axs[1, 0], show=False, title='SFS')
coal.sfs.corr.plot(ax=axs[1, 1], show=False, title='2-SFS')

plt.tight_layout()
plt.show()
    \end{minted}

    \begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{figures/manuscript_basic_example}
        \caption{
            Output from code snippet in Section \ref{sec:code-examples}.
            \textbf{Top left}: population sizes and migration rates over time.
            \textbf{Top right}: tree height distribution. \textbf{Bottom left}: expected SFS.
            \textbf{Bottom right}: 2-SFS correlation matrix.
        }
        \label{fig:simple-example}
    \end{figure}

    \subsection{MLE Inference}\label{subsec:mle-inference}

    % mention state space caching

    \subsection{More complex moments}\label{subsec:other-quantities}


    \section{Discussion}\label{sec:discussion}
    % state space reduction techniques (exploit symmetries, unreachable states, etc)
    % recombination with block counting state space (discuss partial loss of exchangeability of lineages)
    % recombination with MMCs
    % support for diploidy and polyploidy

    \section*{Acknowledgements}

    \newpage
    \bibliography{refs}

    \newpage
    \appendix
    \input{appendix}

\end{document}
